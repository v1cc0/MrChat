# 项目进度

## 当前重点
- 基于现有 Hummingbird 代码梳理的成果，制定聊天界面重构路径、Turso 一体化持久层方案，以及音乐播放模块的并存策略。
- （永久保留）调试或检查本地 Turso 数据库时统一使用 `tursodb` CLI。

## 已完成
- 修复播放列表加载失败：新增通用 `parse_timestamp` 解析函数覆盖 SQLite/Turso 默认时间格式，批量替换 `created_at` 字段解析，并修正播放列表聚合查询列顺序与分组。
- 统一品牌标识：窗口标题、菜单、About/MPRIS/音频设备等用户可见文案更新为 “MrChat”，同时应用 ID 切换为 `org.v1cc0.mrchat`。
- 统一数据目录：所有数据库、配置与缓存改为写入 `~/.local/share/mrchat/`，并在缺失配置时回退检查当前目录、提示用户并弹出配置向导窗口。
- 修复音乐库扫描写入锁：为本地 Turso 启用 WAL + busy_timeout，并为元数据更新新增锁重试逻辑，避免 "database is locked" 导致的批量插入失败。
- [**常驻提醒**] 参见 `docs/turso_database_issues.md`：记录 Turso 数据库在使用过程中的已知问题与解决方案，包括：
  - **Busy Handler 行为差异**：Turso busy handler 与 SQLite 的差异，本项目如何配置 `busy_timeout`
  - **Option 参数绑定 Panic**：turso crate 无法正确处理元组中的 Option<T> 参数，必须在 Rust 层转换为具体值
  - 调试数据库问题时必须优先查阅此文档
- 规避空库统计崩溃：`track_stats` 查询使用 `COALESCE`，`TrackStats::from_row` 对 `total_duration` 为空时回落为 0。
- 读取并梳理 `src/ui`、`src/settings`、`src/services`、`src/media` 等核心模块的职责。
- 识别出 `gpui` 驱动的组件体系（按钮、输入框、模态框、主题）可作为聊天界面的基础。
- 初步整理 Playback/Library 扫描线程等与音频播放高度耦合的部分，后续将作为迁移/替换重点。
- 明确聊天后端统一通过 HTTP API 访问（无论远程还是本地 LLM 服务）。
- 决定保留 Hummingbird 播放器逻辑，作为工作流内的可选媒体播放模块。
- 确认 Turso 作为唯一数据库后端，取代原有 SQLite 依赖。
- 形成《docs/chat_player_architecture.md》架构方案，涵盖模块拆分与 Turso 表设计。
- 搭建 `shared::db::TursoPool` 封装与 `modules/chat` 骨架（状态模型、服务占位、占位 UI）。
- 完成 `modules/chat/storage::ChatDao`，实现 Turso 表建模与会话/消息 CRUD，并接入 `ChatServices`。
- 扩展 `ChatServices` 暴露会话/消息 API，新增 `chat::bootstrap_state` 以异步同步数据；提供 `ChatOverview` 占位视图展示会话/消息概览。
- 将 Turso 聊天服务接入应用启动流程，并在主窗口嵌入 `ChatOverview` 支持基本会话切换与消息加载。
- 新增聊天会话面板与输入框，支持新建会话、发送消息并即时刷新 Turso 状态。
- 引入 `config.sample.toml` 与配置加载逻辑，整合 LLM API 调用并在前端显示助手回复。
- 创建 `config.toml` 模板，集中记录应用、聊天、播放器及 Turso 配置示例。
- 修复编译错误：更正 `TursoDatabase` API 调用（`connection()` → `connect()`），清理未使用的宏定义和导入。
- **完成数据库层完全迁移至 Turso**：
  - 从 `Cargo.toml` 移除 `sqlx` 依赖，添加 `turso` 和 `turso_core` 依赖
  - 为 `TursoDatabase` 添加 `Clone` trait 和多个辅助查询方法（`query_one`, `query_optional`, `query_scalar`, `query_map` 等）
  - 完全重写 `src/library/types.rs`，移除所有 sqlx derive 宏，为所有类型添加手动 `from_row()` 方法
- 完全重写 `src/library/db.rs`，将所有 `sqlx::query_as` 调用转换为 Turso API
  - 更新 `src/ui/app.rs`，采用分离的数据库架构：
    - **`music.db`**: 音乐库功能（扫描、播放、专辑封面等）
    - **`mrchat.db`**: AI 聊天功能（会话、消息等）
  - 迁移 `src/library/scan.rs` 的所有数据库操作（`insert_artist`, `insert_album`, `insert_track`, `delete_track`）至 Turso
  - 更新 `src/ui/assets/db.rs`，使用 Turso 加载专辑封面和缩略图
- 修复类型转换问题：`DateTime<Utc>` 转换为 timestamp，`Vec<u8>` 转换为 `Box<[u8]>`
- 项目成功编译，所有 sqlx 依赖已完全移除
- 移除 Turso 不支持的数据库触发器迁移，转而在扫描线程的删除逻辑中手动清理 `album`、`artist`、`album_path` 依赖，确保迁移可执行且库表保持一致性。
- 为 `TursoDatabase::run_migrations` 引入 `mrchat_migrations` 记录表，按文件粒度跳过已执行迁移，并在检测到重复列/索引时给出告警而不中断。
- 调整迁移脚本以满足 libSQL 要求：`mbid` 默认值改用单引号常量，并保留旧的专辑唯一索引以绕过 DROP 限制，保证现有库可顺利升级。
- **修复 SearchModel 生命周期 panic**：将 `src/ui/search/model.rs` 中的异步任务从使用 `.expect()` 改为优雅处理弱引用失败（`is_err()` 检查并退出循环），避免窗口关闭时后台任务访问已释放实体导致的 panic。
- **修复数据库写入锁问题**：
  - 强制 WAL 模式在数据库打开时必须成功启用，失败则返回错误而非 warn（src/db/mod.rs:28-34）
  - 将 busy_timeout 从 5000ms 增加到 10000ms，提供更长的锁等待时间
  - 优化扫描线程连接使用：整个 metadata 更新（artist/album/track）使用单个连接，减少 3x 连接开销和锁冲突机会
  - 移除冗余的 `apply_pragmas` 函数，WAL 仅在数据库级别设置一次，busy_timeout 在每个连接上设置
- **日志时间戳本地化**：将日志输出的时间戳从 UTC 改为系统本地时间，方便用户阅读（src/main.rs:24-27，启用 tracing-subscriber 的 local-time feature）
- **修复 track.location NOT NULL 约束失败**：`insert_track` 中 `path.to_str()` 和 `parent.to_str()` 返回 `Option<&str>`，当为 None 时导致数据库收到 NULL 值而违反约束。现在添加显式错误处理，确保路径转换失败时立即报错而不是传递 NULL。
- **修复 turso crate Option 参数绑定 panic**：
  - 问题：`insert_album` 使用 `query_one` 传递包含 Option 类型的元组参数（Option<i64>、Option<Vec<u8>>、Option<&str>）时，turso crate 在参数绑定阶段 panic
  - 根本原因：turso crate 0.2.2 无法正确处理元组中的 Option 类型参数，导致"invalid value type"错误
  - 解决方案（src/library/scan.rs:509-546）：
    - 将所有 Option 参数转换为具体值（artist_id → 0, image/thumb → 空Vec, label/catalog/isrc → 空字符串）
    - 修改 SQL（queries/scan/create_album.sql）使用 NULLIF 和 CASE 将特殊值转回 NULL
    - 将 `query_one` + RETURNING id 改为 `execute` + `last_insert_rowid()`
    - 将 ON CONFLICT DO NOTHING 改为 DO UPDATE SET，确保冲突时也能获取 id
  - 额外修复（src/library/types.rs:219-223）：`Album::from_row` 中 release_date 从 Option<String> 改为 Option<i64>，匹配数据库中的 timestamp 存储类型
- **修复 album.release_date 数据损坏导致的启动 panic**：
  - 问题：应用启动时触发 "entered unreachable code: invalid value type" panic，经排查发现 13 个 album 记录的 release_date 列存储了 BLOB 图片数据而非整数时间戳
  - 根本原因：早期版本的 album 插入代码中参数顺序与 SQL 列顺序不匹配，导致图片数据写入错误列
  - 修复方案：执行 `UPDATE album SET release_date = NULL WHERE typeof(release_date) = 'blob'` 清理损坏数据
  - 预防措施：使用位置参数时严格验证参数顺序与 SQL 列顺序一致
- **实现 config.toml scan_directories 配置支持**：
  - 修改 `src/ui/app.rs`：优先使用 config.toml 中的 `player.scan_directories`，如果为空则回退到 settings.json 中的默认路径
  - 支持 `~/` 路径扩展：自动将 `~/music/...` 转换为绝对路径
  - 配置生效后会在日志中输出："使用 config.toml 中的扫描路径: [...]"
- **清理和规范化数据库迁移文件**：
  - 将迁移文件重命名为顺序编号（01-10），去除时间戳前缀，提升可读性
  - 修正 `album.release_date` 数据类型：从 DATE 改为 INTEGER（Unix 时间戳），与代码实现保持一致
  - 为所有迁移文件添加详细注释，说明表结构和字段用途
  - 完整审查所有 `from_row` 实现（Artist, Album, Track, Playlist, PlaylistItem, TrackStats），确认类型安全
  - 审查所有 SQL 查询文件参数顺序，验证与表结构的匹配性
  - 测试迁移文件：在干净数据库上成功执行所有迁移，验证表结构和默认数据正确性
- **修复 Album 结构体列顺序不匹配导致的 panic**：
  - 问题：迁移清理后，新数据库使用时仍然 panic，原因是 `Album::from_row` 列读取顺序与数据库不匹配
  - 根本原因：数据库中没有 `image_mime` 列（只有 Artist 表有），但 `Album` 结构体错误地包含了该字段；数据库中有 `mbid` 列，但结构体缺少该字段
  - 修复方案（src/library/types.rs:192-254）：
    - 从 `Album` 结构体删除 `image_mime` 字段，添加 `mbid` 字段
    - 修复 `Album::from_row` 以正确读取列顺序：跳过位置 8 的 `tags`（暂不解析），读取位置 12 的 `mbid`
  - 预防措施：使用 `SELECT *` 时必须严格匹配表的实际列顺序
- **完全解决 turso crate 0.2.2 参数绑定 bug**：
  - **Bug 1: 无法混合 Vec<u8> (BLOB) 与其他类型**：元组参数中包含 BLOB 和其他类型时，参数顺序会被打乱，导致数据写入错误的列
    - 表现：album.release_date (INTEGER) 被写入 BLOB 图片数据
    - Workaround (src/library/scan.rs:427-583)：分两步插入 album — Step 1 插入非 BLOB 字段，Step 2 单独 UPDATE BLOB 字段
    - 结果：✅ album 插入成功（49 albums）
  - **Bug 2: 无法混合 String 与 i64 类型**：即使只有 3 String + 1 i64 的组合也会导致参数打乱
    - 表现：track.location 显示为数字（实际是 duration 的值），说明参数顺序错乱
    - 尝试的 Workarounds：
      - 分 3 步：Step 1 只插入 String 字段，Step 2 更新 i64 字段，Step 3 更新更多 String 字段 → 失败，0 tracks
      - 调整参数顺序、减少参数数量 → 所有方案均失败
    - **最终解决方案（src/library/scan.rs:201-205, 653-697）**：
      - **完全放弃参数绑定**，使用 SQL 字面值（literal values）
      - 添加 `sql_escape()` 辅助函数处理单引号转义，防止 SQL 注入
      - 将所有参数值直接 format 到 SQL 字符串中：`INSERT INTO track (...) VALUES ('{}', {}, ...)`
      - 调用 `conn.execute(&sql, ())` 执行，不传递任何绑定参数
    - 结果：✅ **track 插入完全成功**，所有字段数据正确（包括日文字符、路径、整数）
  - **根本问题**：turso crate 0.2.2 的参数绑定实现存在严重 bug，无法可靠处理混合类型的元组参数
  - **性能考量**：SQL 字面值方式稍慢于参数绑定，但在音乐库扫描场景下影响可忽略（单次扫描仅发生一次）
  - **长期建议**：考虑向 turso 项目提交 issue，或在 turso crate 修复后恢复参数绑定以提升性能
- **完成代码模块重构 - 三层架构拆分**：
  - 目标：将混乱的单层 `src/` 结构重组为清晰的三模块架构：`chat/`、`shared/`、`player/`
  - 实施步骤：
    - 创建三个新目录：`src/chat/`、`src/shared/`、`src/player/`
    - 使用 `git mv` 移动所有文件以保留 Git 历史：
      - `src/modules/chat/*` → `src/chat/`（聊天模块：models, services, storage, ui）
      - `src/config.rs`, `src/db/`, `src/settings/`, `src/ui/components/`, `src/util.rs` → `src/shared/`（共享组件）
      - `src/devices/`, `src/library/`, `src/media/`, `src/playback/`, `src/services/`, `src/ui/` → `src/player/`（播放器模块）
    - 为每个新模块创建 `mod.rs` 文件，定义清晰的公共接口
    - 更新 `main.rs` 以使用新的模块路径（`mod chat; mod player; mod shared;`）
  - 导入路径修复：
    - **问题**：Agent 的批量 sed 替换导致 785 个错误（将 `gpui::` 错误替换为 `gpplayer::ui::`，产生重复前缀）
    - **解决方案**：手动精确修复 + Agent 辅助，将错误从 785 → 46 → 33 → 27 → 0
    - 修复模式：
      - `player::player::` → `player::`（删除重复前缀）
      - `shared::shared::` → `shared::`（删除重复前缀）
      - `gpplayer::ui::` → `gpui::`（恢复正确的框架名称）
      - `devices::shared::util` → `player::devices::util`（修正跨模块引用）
      - `library::` → `crate::player::library::`（补全完整路径）
      - `crate::player::crate::player::` → `crate::player::`（修复双重 crate 前缀）
  - 结果：**编译成功，0 个错误**，仅剩 33 个未使用代码警告（正常的开发阶段警告）
  - 好处：
    - **清晰的关注点分离**：聊天、播放器、共享组件各自独立
    - **更好的可维护性**：模块边界清晰，依赖关系明确
    - **更容易测试**：每个模块可以独立测试
    - **为未来扩展奠定基础**：新功能可以轻松添加到对应模块
- **修复播放线程空路径 panic**：
  - 问题：数据库中某些 track 记录的 `location` 字段为空字符串，导致播放时在 `src/player/playback/thread.rs:444` 尝试打开空路径文件而 panic
  - 表现：日志显示 `Opening: ""` 后出现 "No such file or directory" 错误并 panic
  - 根本原因：`open()` 函数未验证路径有效性，直接调用 `std::fs::File::open(path).expect()`
  - 解决方案（src/player/playback/thread.rs:417-428）：
    - 在打开文件前检查路径是否为空（`path.as_os_str().is_empty()`）
    - 检查文件是否存在（`path.exists()`）
    - 对无效路径记录错误日志并自动跳到下一首歌曲（`self.next(false)`），避免中断播放
  - 结果：✅ 播放线程遇到无效路径时优雅降级，不再 panic
- **将数据库迁移嵌入二进制文件实现自包含部署**：
  - 问题：二进制文件运行时 panic "migrations directory not found"，因为程序依赖外部 `./migrations` 目录
  - 用户需求：二进制文件应该是自包含的，不需要用户在特定目录下运行或携带额外文件
  - 解决方案：
    - 修改 `TursoDatabase::run_migrations` 接受 `&[(&str, &str)]` 参数而不是文件路径（src/shared/db/mod.rs:58-125）
    - 在 `src/player/ui/app.rs:406-417` 使用 `include_str!` 宏将所有迁移 SQL 文件嵌入二进制
    - 删除运行时文件系统读取逻辑，移除 `fs` 导入
  - 好处：
    - ✅ 二进制文件完全自包含，可以从任何目录运行
    - ✅ 不需要分发 migrations 目录
    - ✅ 首次运行时自动创建并初始化数据库
    - ✅ 迁移历史仍然通过 `mrchat_migrations` 表正确跟踪
  - 测试：从 `/tmp` 目录运行二进制文件成功创建数据库并应用所有 10 个迁移
- **确保数据库迁移在启动时成功运行**：
  - 问题：应用启动时未正确运行数据库迁移，导致后续查询失败
  - 解决方案：在 `src/player/ui/app.rs` 中为两个数据库（`music.db` 和 `mrchat.db`）调用 `run_migrations()`
  - 结果：✅ 应用启动时自动创建表结构，数据库正常工作
- **修复播放线程无限递归导致的栈溢出**：
  - **问题**：当数据库中 track 的 `location` 字段为空字符串时，播放线程陷入无限递归导致栈溢出
  - **表现**：日志显示大量 "Opening: """ 和 "Cannot open file: path is empty"，最终 "thread 'playback' has overflowed its stack"
  - **根本原因**：
    - `open()` 函数检测到空路径后调用 `self.next(false)` 尝试下一首
    - `next()` 函数又调用 `self.open(&path)` 打开下一首
    - 当队列中所有路径都为空时，形成 `open() → next() → open() → next()...` 无限循环
  - **解决方案**（src/player/playback/thread.rs:109-151, 417-550）：
    - 添加 `consecutive_failures: usize` 字段跟踪连续失败次数
    - 在 `open()` 中遇到空路径或不存在的文件时增加计数器
    - 当连续失败超过 10 次时，调用 `self.stop()` 停止播放而不是继续尝试
    - 成功打开文件后重置计数器为 0
  - **结果**：✅ 播放线程遇到无限递归时不再崩溃，最多尝试 10 次后自动停止
  - **后续**：这只是防御性修复，根本问题是 Track::from_row 读取列顺序错误（见下一条）
- **修复 Track::from_row 列顺序错误导致路径为空**：
  - **问题**：点击歌曲播放时，队列中的路径全部为空字符串 `""`，触发无限递归防御机制
  - **根本原因**（src/player/library/types.rs:273-299）：
    - track 表实际列顺序：0-7 基本字段，**8: genres, 9: tags, 10: location**, 11: artist_names, 12: folder
    - Track::from_row **错误地**将第 8 列当作 location 读取（实际是 genres），第 9 列当作 artist_names 读取（实际是 tags）
    - 由于 genres 通常为空，导致读取的 location 变成空字符串
  - **发现过程**：
    - 用户报告点击播放后仍然出现空路径错误
    - 数据库查询确认所有 track.location 字段都有有效值
    - 通过 `PRAGMA table_info(track)` 发现 track 表有 13 列，而不是预期的 10 列
    - genres 和 tags 列在 location 之前，导致列偏移错误
  - **解决方案**：
    - 修正 Track::from_row 的列读取顺序：
      - genres: 第 8 列 → None（暂不解析）
      - tags: 第 9 列 → None（暂不解析）
      - location: **第 10 列**（之前错误地读第 8 列）
      - artist_names: **第 11 列**（之前错误地读第 9 列）
      - folder: 第 12 列（不在结构体中，忽略）
  - **结果**：✅ 播放功能完全正常，所有歌曲路径正确加载
  - **教训**：使用 `SELECT *` 时必须严格匹配表的实际列顺序，建议在数据库 schema 变更后及时更新所有 from_row 实现
- **修复播放控制按钮键盘快捷键冲突**：
  - **问题**：点击暂停按钮时，空格键事件被发送到聊天输入框，导致输入空格而不是暂停播放
  - **根本原因**：
    - 播放控制按钮使用 `window.dispatch_action(Box::new(PlayPause), cx)` 触发 action
    - 空格键绑定到 PlayPause action（global_actions.rs:40）
    - dispatch_action 会触发键绑定系统，导致空格键事件传播到当前焦点元素（聊天输入框）
    - 其他按钮（shuffle, repeat）直接调用 `GPUIPlaybackInterface` 方法，没有这个问题
  - **解决方案**（src/player/ui/controls.rs）：
    - 改为直接调用 `GPUIPlaybackInterface` 的方法，绕过 action 系统：
      - Previous 按钮：调用 `interface.previous()`（301行）
      - Play/Pause 按钮：根据状态调用 `interface.pause()` 或 `interface.play()`（323-330行）
      - Next 按钮：调用 `interface.next()`（357行）
    - 这样做的好处：
      - 不触发键绑定系统，避免键盘事件传播
      - 与 shuffle/repeat 按钮的实现方式一致
      - 更直接、更高效
  - **调试日志**（保留用于将来调试）：
    - global_actions.rs:75-93：记录 PlayPause action 触发和状态判断
    - thread.rs:293：记录所有接收到的命令
    - thread.rs:318-325：记录 pause() 调用和状态变化
    - thread.rs:877-883：记录 stop() 调用
  - **结果**：✅ 播放控制按钮现在正常工作，不会向聊天输入框发送空格键
  - **用户确认**：所有播放控制按钮（播放/暂停、上一首、下一首、随机、重复）均正常工作

## v0.0.2 发布说明（2025-10-15）

本版本主要修复了数据库迁移到 Turso 后的播放功能问题，以及 UI 交互问题。

### 主要修复
1. **数据库层完全迁移至 Turso**：移除所有 sqlx 依赖，完成向 Turso/libSQL 的迁移
2. **修复播放线程空路径 panic**：添加路径有效性检查，防止空路径导致的崩溃
3. **修复播放线程无限递归**：添加连续失败计数器，防止栈溢出
4. **修复 Track::from_row 列顺序错误**：修正数据库列读取顺序，解决所有歌曲路径为空的问题
5. **修复播放控制按钮键盘快捷键冲突**：改为直接调用接口方法，避免空格键事件传播到聊天输入框
6. **嵌入数据库迁移文件**：使用 `include_str!` 实现自包含部署

### 已知问题
- Symphonia MP3 解码器偶尔会输出 `invalid main_data_begin` 警告（不影响播放）

### 技术债务清理
- 规范化数据库迁移文件命名（01-10.sql）
- 添加完整的迁移注释和字段说明
- 记录 Turso 参数绑定 bug 及解决方案（docs/turso_database_issues.md）

## 待办
- 丰富聊天域模型细节（上下文截断策略、消息元数据）并串联 Turso DAO。
- 拟定 UI 线路图：对齐现有窗口骨架（`WindowShadow`）及组件布局，规划对话列表区、消息区、输入区。
- 规划 API Key 与 Turso 连接配置的存放方式，确保热更新与启动流程一致。
- 设计音乐模块与聊天界面的模块化隔离（启动/挂起/控制接口），确保互不干扰。
- ~~评估并改造音乐库扫描/查询/缓存逻辑以适配 Turso API~~（已完成）
- ~~实现 Turso 连接配置加载 + 健康检查命令，补齐 CRUD 基础~~（已完成）
- ~~排查 SearchModel 在窗口退出时的弱引用崩溃，补充生命周期守卫~~（已完成）
- 为聊天服务层提供最小 API（会话创建、消息写入）并准备集成测试框架。
- 设计聊天 UI 原型并扩展 `ChatOverview`（新建会话、消息输入/流式呈现、错误提示）。
- 拆分聊天服务错误处理/日志策略，补充落地的 tracing 输出格式。
- 测试数据库迁移的功能完整性（library 扫描、封面加载等）。
- 为音乐库删除路径补充集成测试/回归案例，验证手动级联清理行为（album/artist/album_path）。
